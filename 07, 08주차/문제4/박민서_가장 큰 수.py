def solution(numbers):
    answer = ''
    numbers = [str(i) for i in numbers] # 문자열 정렬을 선택 => 자릿수끼리 비교해야 하니까
    numbers.sort(key=lambda x:x*4, reverse=True)
    # numbers의 각 원소는 1000이하 (최대 4자리)
    # '34'와 '3'을 비교한다고 가정 => 34가 3보다 앞에 있어야함
    # 처음 생각: 맨 앞자리부터 하나하나씩 비교해야 함, 이때, 자릿수가 다르면 작은 자릿수를 가진 쪽에서 멈춰야함
    # 예) 1번째 비교 => "34"의 '3' vs "3"의 '3' 2번째 비교 => "34"의 '4' vs "3"의 '3'[멈춰서 비교]
    # '30'과 '3'을 비교했을때는 3이 30보다 앞에 있어야함
    # '멈춰서 비교' 한다는 그 함수를 구현하고 lambda에 넣기 어렵다고 판단..
    # 이를 해결하기 위해, 문자를 반복해서 적고 그것들로 비교 (앞에서 최대 2자리[자릿수가 가장 많은 수의 자릿수]까지만 비교할거고 그 이후의 자릿수 비교는 무의미)
    # 34 vs 3 => '34343434' (big) vs '3333', '30' vs '3' => '30303030' vs '3333' (big)
    # (str) * 4 => (str)(str)(str)(str)
    answer = "".join(numbers) if sum([int(i) for i in numbers]) != 0 else '0'
    # 11번만 틀리길래 찾아보니 [0,0,0,0]인 경우엔 답이 '0' 이라길래 코드 수정
    return answer

'''
정확성  테스트
테스트 1 〉	통과 (69.53ms, 23.1MB)
테스트 2 〉	통과 (28.94ms, 17.1MB)
테스트 3 〉	통과 (78.10ms, 27.2MB)
테스트 4 〉	통과 (1.44ms, 10.4MB)
테스트 5 〉	통과 (55.16ms, 21.6MB)
테스트 6 〉	통과 (44.38ms, 20.1MB)
테스트 7 〉	통과 (0.05ms, 10.3MB)
테스트 8 〉	통과 (0.03ms, 10.3MB)
테스트 9 〉	통과 (0.04ms, 10.3MB)
테스트 10 〉	통과 (0.03ms, 10.5MB)
테스트 11 〉	통과 (0.04ms, 10.3MB)
테스트 12 〉	통과 (0.02ms, 10.4MB)
테스트 13 〉	통과 (0.02ms, 10.5MB)
테스트 14 〉	통과 (0.04ms, 10.3MB)
테스트 15 〉	통과 (0.02ms, 10.4MB)
채점 결과
정확성: 100.0
합계: 100.0 / 100.0
'''