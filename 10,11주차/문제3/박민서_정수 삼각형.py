def solution(triangle):
    # 위 -> 아래 방향은 중간중간 경우의 수가 많음
    # 아래 -> 위 방향으로 계산,, (어쨌든 결과는 맨 아래 숫자를 만나야 끝나니까)
    # 바로 위로 올라갈때, 왼쪽과 오른쪽 중 더 큰 숫자를 위로 올라가면서 더하면 됨.
    # 참고함
    
    my_list = [[0] * i for i in range(1, len(triangle)+1)] # triangle과 똑같은 형태, 0만 채운 배열 생성
    my_list[-1] = triangle[-1] # 마지막 줄 복사
    
    for i in range(len(my_list) - 2, -1, -1): # 마지막줄 바로 윗 줄부터 꼭대기까지 채우는 방향
        for j in range(len(triangle[i])):
            my_list[i][j] += triangle[i][j] + max(my_list[i+1][j], my_list[i+1][j+1]) # 바로 윗 줄들의 요소 =  왼쪽과 오른쪽을 비교해서 더 큰 숫자와 더한 값
    
    return my_list[0][0]


'''
정확성  테스트
테스트 1 〉	통과 (0.01ms, 9.16MB)
테스트 2 〉	통과 (0.04ms, 9.27MB)
테스트 3 〉	통과 (0.05ms, 9.25MB)
테스트 4 〉	통과 (0.18ms, 9.26MB)
테스트 5 〉	통과 (1.41ms, 9.37MB)
테스트 6 〉	통과 (0.36ms, 9.19MB)
테스트 7 〉	통과 (1.26ms, 9.48MB)
테스트 8 〉	통과 (0.30ms, 9.38MB)
테스트 9 〉	통과 (0.02ms, 9.19MB)
테스트 10 〉	통과 (0.33ms, 9.29MB)
효율성  테스트
테스트 1 〉	통과 (44.03ms, 16.9MB)
테스트 2 〉	통과 (31.63ms, 15.3MB)
테스트 3 〉	통과 (45.45ms, 17.9MB)
테스트 4 〉	통과 (40.47ms, 16.9MB)
테스트 5 〉	통과 (38.06ms, 16.4MB)
테스트 6 〉	통과 (51.99ms, 18.3MB)
테스트 7 〉	통과 (44.79ms, 17.5MB)
테스트 8 〉	통과 (36.83ms, 16.2MB)
테스트 9 〉	통과 (37.46ms, 16.4MB)
테스트 10 〉	통과 (44.01ms, 17.7MB)
채점 결과
정확성: 64.3
효율성: 35.7
합계: 100.0 / 100.0
'''